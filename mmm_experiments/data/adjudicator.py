import msgpack
import logging
from confluent_kafka import Consumer

from therading import Lock

logger = logging.getLogger(name="mmm.kafka")


class RecConsumer:
    """
    Processes reccomendations from (many) agents.

    There is no default configuration. A reasonable configuration for production is
        consumer_config={
            "auto.offset.reset": "latest"
        }

    Parameters
    ----------
    topics : list of str
        List of existing_topics as strings such as ["topic-1", "topic-2"]
    bootstrap_servers : str
        Comma-delimited list of Kafka server addresses as a string
        such as ``'broker1:9092,broker2:9092,127.0.0.1:9092'``
    group_id : str
        Required string identifier for the consumer's Kafka Consumer group.
    consumer_config : dict
        Override default configuration or specify additional configuration
        options to confluent_kafka.Consumer.
    polling_duration : float
        Time in seconds to wait for a message before running function work_during_wait
        in the _poll method. Default is 0.05.
    deserializer : function, optional
        Function to deserialize data. Default is msgpack.loads.
    process_document : function(consumer, topic, payload), optional
        A function that procceses received documents, this allows you to have custom document
        processing without the need to make a subclass. The function signature must match
        BlueskyConsumer.process_document(consumer, topic, payload).

    Example
    -------

    Print all documents generated by remote RunEngines.

    >>> consumer = BlueskyConsumer(
    >>>         topics=["abc.bluesky.documents", "xyz.bluesky.documents"],
    >>>         bootstrap_servers='localhost:9092',
    >>>         group_id="print.document.group",
    >>>         consumer_config={
    >>>             "auto.offset.reset": "latest"  # consume messages published after this consumer starts
    >>>         }
    >>>         process_document=lambda consumer, topic, name, doc: print(doc)
    >>>    )
    >>> bluesky_consumer.start(continue_polling=continue_polling)  # runs until continue_polling() returns False
    """

    def __init__(
        self,
        topics,
        bootstrap_servers,
        group_id,
        consumer_config=None,
        polling_duration=0.05,
        deserializer=msgpack.loads,
        process_document=None,
    ):
        self._topics = topics
        self._bootstrap_servers = bootstrap_servers
        self._group_id = group_id
        self._deserializer = deserializer
        self._process_document = process_document
        self.polling_duration = polling_duration

        self._consumer_config = dict()
        if consumer_config is not None:
            self._consumer_config.update(consumer_config)

        if "group.id" in self._consumer_config:
            raise ValueError("do not specify 'group.id' in consumer_config, use only the 'group_id' argument")
        else:
            self._consumer_config["group.id"] = group_id

        if "bootstrap.servers" in self._consumer_config:
            self._consumer_config["bootstrap.servers"] = ",".join(
                [bootstrap_servers, self._consumer_config["bootstrap.servers"]]
            )
        else:
            self._consumer_config["bootstrap.servers"] = bootstrap_servers

        logger.debug(
            "BlueskyConsumer configuration:\n%s",
            self._consumer_config,
        )
        logger.debug("subscribing to Kafka topic(s): %s", topics)

        self.consumer = Consumer(self._consumer_config)
        self.consumer.subscribe(topics=topics)
        self.closed = False

    def _poll(self, *, continue_polling=None, work_during_wait=None):
        """
        This method defines the polling loop in which messages are pulled from
        one or more Kafka brokers and processed with self.process().

        The polling loop will be interrupted if self.process() returns False.

        Parameters
        ----------
        continue_polling: function(), optional
            a parameter-less function called before every call to Consumer.poll,
            the intention is to allow an outside force to stop the Consumer

        work_during_wait : function(), optional
            a parameter-less function to be called between calls to Consumer.poll
        """

        if continue_polling is None:

            def never_stop_polling():
                return True

            continue_polling = never_stop_polling

        if work_during_wait is None:

            def no_work_during_wait():
                # do nothing between message deliveries
                pass

            work_during_wait = no_work_during_wait

        while continue_polling():
            try:
                msg = self.consumer.poll(self.polling_duration)
                if msg is None:
                    # no message was delivered
                    # do some work before polling again
                    work_during_wait()
                elif msg.error():
                    logger.error("Kafka Consumer error: %s", msg.error())
                elif self.process(msg) is False:
                    logger.info("breaking out of polling loop after process(msg) returned False")
                    break
                else:
                    # poll again
                    pass
            except KeyboardInterrupt as keyboard_interrupt:
                logger.exception(keyboard_interrupt)
                raise
            except Exception as exc:
                logger.exception(exc)

        logger.warning("continue_polling() returned False")
        self.stop()

    def process(self, msg):
        """
        Deserialize the Kafka message and extract the bluesky document.

        Document processing is delegated to self.process_document(name, document).

        This method can be overridden to customize message handling.

        Parameters
        ----------
        msg : Kafka message

        Returns
        -------
        continue_polling : bool
            return True to continue polling, False to break out of the polling loop
        """
        payload = self._deserializer(msg.value())
        logger.debug(
            f"{type(self)} deserialized payload with " "topic %s for Kafka Consumer name: %s doc: %s",
            msg.topic(),
            payload,
        )
        continue_polling = self.process_document(msg.topic(), payload)
        return continue_polling

    def process_document(self, topic, payload):
        """
        Subclasses may override this method to process documents.
        Alternatively a document-processing function can be specified at init time
        and it will be called here. The function must have the same signature as
        this method (except for the `self` parameter).

        If this method returns False the BlueskyConsumer will break out of the
        polling loop.

        Parameters
        ----------
        topic : str
            the Kafka topic of the message containing name and doc
        name : str
            bluesky document name: `start`, `descriptor`, `event`, etc.
        doc : dict
            bluesky document

        Returns
        -------
        continue_polling : bool
            return False to break out of the polling loop, return True to continue polling
        """
        if self._process_document is None:
            raise NotImplementedError(
                "This class must either be subclassed to override the "
                "process_document method, or have a process function passed "
                "in at init time via the process_document parameter."
            )
        else:
            continue_polling = self._process_document(self.consumer, topic, payload)
            return continue_polling

    def start(self, continue_polling=None, work_during_wait=None):
        """
        Start the polling loop.

        Parameters
        ----------
        continue_polling: function(), optional
            a parameter-less function called before every call to Consumer.poll,
            the intention is to allow outside logic to stop the Consumer

        work_during_wait : function(), optional
            a parameter-less function to be called between calls to Consumer.poll

        """
        if self.closed:
            raise RuntimeError(
                "This BlueskyConsumer has already been "
                "started and interrupted. Create a fresh "
                f"instance with {repr(self)}"
            )
        try:
            self._poll(continue_polling=continue_polling, work_during_wait=work_during_wait)
        except Exception:
            self.stop()
            raise
        finally:
            self.stop()

    def stop(self):
        """
        Close the underlying consumer.
        """
        self.consumer.close()
        self.closed = True
